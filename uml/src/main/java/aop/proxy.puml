@startuml
'https://plantuml.com/class-diagram

'DarkGrey 标记接口

interface Ordered {
	int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;
	int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
	+ int getOrder()
}

'joinpoint
interface Joinpoint
interface Pointcut
interface ExpressionPointcut extends Pointcut
class ComposablePointcut implements Pointcut

interface Invocation extends Joinpoint
interface ConstructorInvocation extends Invocation
interface MethodInvocation extends Invocation
interface ProxyMethodInvocation extends MethodInvocation

'Advice
package advicesAll {

    package adviceInterfaces{

        interface Advice
        interface AfterAdvice
        AfterAdvice --|> Advice
        interface DynamicIntroductionAdvice
        DynamicIntroductionAdvice --|> Advice

        interface AfterReturningAdvice extends AfterAdvice{
            void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target)
        }
        interface ThrowsAdvice extends AfterAdvice
        interface BeforeAdvice extends Advice {
        }
        interface MethodBeforeAdvice  {
            void before(Method method, Object[] args, @Nullable Object target)
        }
        MethodBeforeAdvice --|> BeforeAdvice
    }





    'Interceptor
    package InterceptorInterfaces{
        interface Interceptor extends Advice
        interface ConstructorInterceptor extends Interceptor
        interface MethodInterceptor extends Interceptor{
            + Object invoke(MethodInvocation mi)
        }
    }

    'wrap
    package wrapAdviceToInterceptor{
        class MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice {
            - MethodBeforeAdvice advice
        }

        class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice{
            - AfterReturningAdvice advice
        }
        class ThrowsAdviceInterceptor implements MethodInterceptor, AfterAdvice {
            - Object throwsAdvice
        }
    }



    package aspectJ {
        interface AspectJPrecedenceInformation{
            + int getOrder()
        }

        abstract class AbstractAspectJAdvice
        AbstractAspectJAdvice ..|> Advice
        AbstractAspectJAdvice ..|> AspectJPrecedenceInformation

        AbstractAspectJAdviceImpls -u-|> AbstractAspectJAdvice #line:MediumBlue
        package AbstractAspectJAdviceImpls{
            'class AspectJMethodBeforeAdvice extends AbstractAspectJAdvice implements MethodBeforeAdvice
            AspectJMethodBeforeAdvice ..|> MethodBeforeAdvice

            'class AspectJAfterReturningAdvice extends AbstractAspectJAdvice implements AfterReturningAdvice, AfterAdvice
            AspectJAfterReturningAdvice ..|> AfterReturningAdvice

            package MethodInterceptors {
                'class AspectJAfterThrowingAdvice extends AbstractAspectJAdvice implements MethodInterceptor, AfterAdvice
                class AspectJAfterThrowingAdvice
                AspectJAfterThrowingAdvice ..|> AfterAdvice
                'class AspectJAroundAdvice extends AbstractAspectJAdvice implements MethodInterceptor
                class AspectJAroundAdvice
                'class AspectJAfterAdvice extends AbstractAspectJAdvice implements MethodInterceptor, AfterAdvice
                class AspectJAfterAdvice
                AspectJAfterAdvice ..|> AfterAdvice
            }
            MethodInterceptors ..|> MethodInterceptor #line:red
        }
    }
}



interface IntroductionInfo

'Advisor
interface Advisor
interface PointcutAdvisor extends Advisor
interface InstantiationModelAwarePointcutAdvisor extends PointcutAdvisor
interface IntroductionAdvisor extends Advisor, IntroductionInfo

abstract class AbstractPointcutAdvisor implements PointcutAdvisor{
    + int getOrder()
}
abstract class AbstractGenericPointcutAdvisor extends AbstractPointcutAdvisor
abstract class AbstractBeanFactoryPointcutAdvisor extends AbstractPointcutAdvisor

class AspectJPointcutAdvisor implements PointcutAdvisor {
    - AbstractAspectJAdvice advice
    - final Pointcut pointcut
    + int getOrder()
}
note bottom of AspectJPointcutAdvisor
aop 标签的advisor ,一个advice 一个advisor
end note
class DeclareParentsAdvisor implements IntroductionAdvisor
class DefaultIntroductionAdvisor implements IntroductionAdvisor

class DefaultPointcutAdvisor extends AbstractGenericPointcutAdvisor
note bottom of DefaultPointcutAdvisor
DefaultAdvisorAdapterRegistry.wrap 将advice包装成advisor
MethodInterceptor 包装成 DefaultPointcutAdvisor
end note


class ProxyProcessorSupport extends ProxyConfig implements  BeanClassLoaderAware, AopInfrastructureBean {
     + int getOrder()
}


' beanPostProcessor
package beanPostProcessor{
    abstract class AbstractAutoProxyCreator #tan extends .ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor{
        - Map<Object, Class<?>> proxyTypes
        - Map<Object, Boolean> advisedBeans
        + Object postProcessAfterInitialization(@Nullable Object bean, String beanName)
    }
    note right of AbstractAutoProxyCreator
    **advisedBeans**bean创建时会判断,然后缓存结果
    key:beanName
    value:是否需要进行代理
    ===
    **advisedBeans**
    key:beanName
    value:代理类的class对象
    end note

    abstract class AbstractAdvisorAutoProxyCreator  extends AbstractAutoProxyCreator  {

    }


    class AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator
    class InfrastructureAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator
    class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator


}
note top of beanPostProcessor
AopConfigUtils.APC_PRIORITY_LIST 保存了3个类的优先级,以索引顺序作为优先级,越大优先级越高
    APC_PRIORITY_LIST.add(InfrastructureAdvisorAutoProxyCreator.class);
    APC_PRIORITY_LIST.add(AspectJAwareAdvisorAutoProxyCreator.class);
    APC_PRIORITY_LIST.add(AnnotationAwareAspectJAutoProxyCreator.class);
注册时会判断是否已经存在该类型的beanPostProcessor,
如果存在继续判断优先级,如果比原来的高,则修改beanDefinition的beanClass
为当前的beanPostProcessor
end note


' factory
package factory{
    interface Advised #AntiqueWhite extends .TargetClassAware
    note top of Advised
    保存aop代理工厂的配置信息
    从spring中获取的aop代理对象,都可以转成该接口
    end note

    class AdvisedSupport extends ProxyConfig implements Advised{
        - Map<MethodCacheKey, List<Object>> methodCache
        - List<Advisor> advisors
    }


    interface FactoryBean
    note top
    BeanFactory.FACTORY_BEAN_PREFIX="&"
    所有注册到容器中的 factoryBean 的名字前缀
    前缀+beanName获取factoryBean实例,
    beanName获取factoryBean创建的实例
    end note


    class ProxyCreatorSupport extends AdvisedSupport{
        - AopProxyFactory aopProxyFactory
    }

    ProxyCreatorSupport::aopProxyFactory -----> AopProxyFactory



    class ProxyFactory extends ProxyCreatorSupport {
        + Object getProxy()
        + Object getProxy(@Nullable ClassLoader classLoader)
    }
    note bottom of ProxyFactory
    不依赖Ioc容器方式,创建proxy对象
    end note

    class ScopedProxyFactoryBean extends ProxyConfig implements FactoryBean,AopInfrastructureBean{

    }
    note bottom of ScopedProxyFactoryBean
    <aop:scoped-proxy />
    end note

    class MethodLocatingFactoryBean implements FactoryBean
    note bottom of MethodLocatingFactoryBean
    返回一个方法
    end note

    class ProxyFactoryBean extends ProxyCreatorSupport implements FactoryBean{

    }
    note bottom of ProxyFactoryBean
    Ioc容器创建proxy对象
    end note
    class AspectJProxyFactory extends ProxyCreatorSupport



    interface AopProxyFactory {
        + AopProxy createAopProxy(AdvisedSupport config)
    }
    class DefaultAopProxyFactory implements AopProxyFactory {
    }
    AopProxyFactory::createAopProxy ----> proxy.AopProxy : 委托创建代理对象

}

'proxy
package proxy {


    interface AopProxy{
        + Object getProxy();
        + Object getProxy(@Nullable ClassLoader classLoader);
    }
    note bottom of AopProxy
    CglibAopProxy
    调用AopProxyUtils.completeProxiedInterfaces 找出aop需要的接口
    计算时是根据 AdvisedSupport 的子类,即实际的代理工厂来找的
    SpringProxy、Advised
    ===
    子类调用拦截器都是通过, ReflectiveMethodInvocation
    end note
    class CglibAopProxy implements AopProxy
    class ObjenesisCglibAopProxy extends CglibAopProxy
    class JdkDynamicAopProxy implements AopProxy, InvocationHandler



}

'===========


AbstractAutoProxyCreator::postProcessAfterInitialization ---> ProxyFactory : 调用factory创建代理对象
'static
card static {
    class AopContext{
        - ThreadLocal<Object> currentProxy
    }
}



class LazyInitTargetSource extends AbstractBeanFactoryBasedTargetSource
abstract class AbstractPrototypeBasedTargetSource extends AbstractBeanFactoryBasedTargetSource
class PrototypeTargetSource extends AbstractPrototypeBasedTargetSource
class SimpleBeanTargetSource extends AbstractBeanFactoryBasedTargetSource
abstract class AbstractBeanFactoryBasedTargetSource implements TargetSource
abstract class AbstractPoolingTargetSource extends AbstractPrototypeBasedTargetSource implements PoolingConfig
class CommonsPool2TargetSource extends AbstractPoolingTargetSource

interface TargetSource extends TargetClassAware
abstract class AopUtils{
	+ static boolean isAopProxy(@Nullable Object object)
	+ static boolean isJdkDynamicProxy(@Nullable Object object)
	+ static boolean isCglibProxy(@Nullable Object object)
}
interface TargetClassAware {
	+ Class<?> getTargetClass();
}
interface AopInfrastructureBean #DarkGrey
note top
标记接口,所有标记这个接口的类,Spring
不会使用自动代理,即使pointcut匹配
end note


class ScopedObject



interface TransactionalProxy #DarkGrey extends SpringProxy
interface SpringProxy #DarkGrey
note top
所有Spring的AOP代理对象都会实现,标记接口
可以用来检查代理对象是不是生成的
end note

class ProxyConfig{
	- boolean proxyTargetClass = false;
	- boolean optimize = false;
	- boolean opaque = false;
	- boolean exposeProxy = false;
	- boolean frozen = false;
	+ void copyFrom(ProxyConfig other)
}
skinparam GroupInheritance 4



interface AspectInstanceFactory {
     + int getOrder()
}
class SimpleBeanFactoryAwareAspectInstanceFactory implements AspectInstanceFactory








@enduml