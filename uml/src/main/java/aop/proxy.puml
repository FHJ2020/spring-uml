@startuml
'https://plantuml.com/class-diagram


'joinpoint
interface Joinpoint
interface Pointcut
interface ExpressionPointcut extends Pointcut
class ComposablePointcut implements Pointcut

interface Invocation extends Joinpoint
interface ConstructorInvocation extends Invocation
interface MethodInvocation extends Invocation
interface ProxyMethodInvocation extends MethodInvocation

'Advice
interface Advice
interface AfterAdvice extends Advice
interface AfterReturningAdvice extends AfterAdvice
interface ThrowsAdvice extends AfterAdvice
interface BeforeAdvice extends Advice
interface MethodBeforeAdvice extends BeforeAdvice


interface AspectJPrecedenceInformation extends Ordered
abstract class AbstractAspectJAdvice implements Advice, AspectJPrecedenceInformation


class AspectJMethodBeforeAdvice extends AbstractAspectJAdvice implements MethodBeforeAdvice
class AspectJAfterAdvice extends AbstractAspectJAdvice implements MethodInterceptor, AfterAdvice
class AspectJAfterReturningAdvice extends AbstractAspectJAdvice implements AfterReturningAdvice, AfterAdvice
class AspectJAfterThrowingAdvice extends AbstractAspectJAdvice implements MethodInterceptor, AfterAdvice
class AspectJAroundAdvice extends AbstractAspectJAdvice implements MethodInterceptor



'Interceptor
interface Interceptor extends Advice
interface ConstructorInterceptor extends Interceptor
interface MethodInterceptor extends Interceptor
interface DynamicIntroductionAdvice extends Advice





interface IntroductionInfo




'Advisor
interface Advisor
interface PointcutAdvisor extends Advisor
interface InstantiationModelAwarePointcutAdvisor extends PointcutAdvisor
interface IntroductionAdvisor extends Advisor, IntroductionInfo
class AspectJPointcutAdvisor implements PointcutAdvisor, Ordered

'===========

'static
card static {
    class AopContext{
        - ThreadLocal<Object> currentProxy
    }
}



class LazyInitTargetSource extends AbstractBeanFactoryBasedTargetSource
abstract class AbstractPrototypeBasedTargetSource extends AbstractBeanFactoryBasedTargetSource
class PrototypeTargetSource extends AbstractPrototypeBasedTargetSource
class SimpleBeanTargetSource extends AbstractBeanFactoryBasedTargetSource
abstract class AbstractBeanFactoryBasedTargetSource implements TargetSource
abstract class AbstractPoolingTargetSource extends AbstractPrototypeBasedTargetSource implements PoolingConfig
class CommonsPool2TargetSource extends AbstractPoolingTargetSource

interface TargetSource extends TargetClassAware
abstract class AopUtils{
	+ static boolean isAopProxy(@Nullable Object object)
	+ static boolean isJdkDynamicProxy(@Nullable Object object)
	+ static boolean isCglibProxy(@Nullable Object object)
}
interface TargetClassAware {
	+ Class<?> getTargetClass();
}
interface AopInfrastructureBean
note top
标记接口,所有标记这个接口的类,Spring
不会使用自动代理,即使pointcut匹配
end note

class DefaultAopProxyFactory implements AopProxyFactory
class ScopedObject
interface Advised extends TargetClassAware
class AdvisedSupport extends ProxyConfig implements Advised
class ProxyCreatorSupport extends AdvisedSupport{
    - AopProxyFactory aopProxyFactory
}
class ProxyFactory extends ProxyCreatorSupport
note bottom of ProxyFactory
不依赖Ioc容器方式,创建proxy对象
end note

class ProxyFactoryBean extends ProxyCreatorSupport implements FactoryBean{

}
note bottom of ProxyFactoryBean
Ioc容器创建proxy对象
end note
class AspectJProxyFactory extends ProxyCreatorSupport
interface FactoryBean
note top
BeanFactory.FACTORY_BEAN_PREFIX="&"
所有注册到容器中的 factoryBean 的名字前缀
前缀+beanName获取factoryBean实例,
beanName获取factoryBean创建的实例
end note

interface TransactionalProxy extends SpringProxy
interface SpringProxy
note top
所有Spring的AOP代理对象都会实现,标记接口
可以用来检查代理对象是不是生成的
end note
AopUtils -- SpringProxy

class ProxyConfig{
	- boolean proxyTargetClass = false;
	- boolean optimize = false;
	- boolean opaque = false;
	- boolean exposeProxy = false;
	- boolean frozen = false;
	+ void copyFrom(ProxyConfig other)
}
skinparam GroupInheritance 4
class ScopedProxyFactoryBean extends ProxyConfig implements FactoryBean,AopInfrastructureBean{

}

FactoryBean --> Bean : createBean
class MethodLocatingFactoryBean implements FactoryBean
note bottom of MethodLocatingFactoryBean
返回一个方法
end note
interface AspectInstanceFactory extends Ordered
class SimpleBeanFactoryAwareAspectInstanceFactory implements AspectInstanceFactory





package aop生成的beanDefinition对象图 #tan {

'method
    card methodDefinition {
        map "methodDefinition.PropertyValues" as methodPropertyValues {
            targetBeanName => aspectName(ref)
            methodName => method(method)
            synthetic => true
        }
        map methodDefinition {
            class => RootBeanDefinition
            beanClass => MethodLocatingFactoryBean.class
            getPropertyValues *--> methodPropertyValues
        }
    }


'aspectFactory
    card aspectFactoryDef {
        map "aspectFactoryDef.PropertyValues" as aspectFactoryPropertyValues {
            aspectBeanName => aspectName(ref)
            synthetic => true
        }
            map aspectFactoryDef {
            class => RootBeanDefinition
            beanClass => SimpleBeanFactoryAwareAspectInstanceFactory.class
            getPropertyValues *--> aspectFactoryPropertyValues
        }
    }

'pointcut
    card pointcutDefinition {
        map "pointcutDefinition.PropertyValues" as pointcutPropertyValues {
            expression => expression
        }
        map pointcutDefinition {
            class => RootBeanDefinition
            beanClass => AspectJExpressionPointcut.class
            scope => BeanDefinition.SCOPE_PROTOTYPE
            synthetic => true
            getPropertyValues *--> pointcutPropertyValues
        }
    }


'pointcut-ref
    card RuntimeBeanReference {
        map RuntimeBeanReference {
            beanName => beanName(pointcut-ref)
            beanType => null
            toParent => false
        }
    }

'advice
    card adviceDefinition {
        map AdviceClass {
            before => AspectJMethodBeforeAdvice.class
            after => AspectJAfterAdvice.class
            after-returning => AspectJAfterReturningAdvice.class
            after-throwing => AspectJAfterThrowingAdvice.class
            around => AspectJAroundAdvice.class
        }
        map "adviceDefinition.PropertyValues" as advicePropertyValues {
            aspectName => aspectName(ref)
            declarationOrder => xml 中定义的顺序
            returningName => returning
            throwingName => throwing
            argumentNames => arg-names
        }
        map "adviceDefinition.ConstructorArgumentValues" as adviceConstructorArgumentValues {
            Map<Integer, ValueHolder> indexedArgumentValues => 下面是map的key指向的值
            0 =>
            1_pointcut =>
            1_pointcut_ref =>
            2 =>
        }
        adviceConstructorArgumentValues::0 --> methodDefinition
        adviceConstructorArgumentValues::2 --> aspectFactoryDef
        adviceConstructorArgumentValues::1_pointcut --> pointcutDefinition
        adviceConstructorArgumentValues::1_pointcut_ref --> RuntimeBeanReference

        map adviceDefinition {
            class => RootBeanDefinition
            synthetic => false
            getPropertyValues *--> advicePropertyValues
            beanClass *----> AdviceClass
            getConstructorArgumentValues *----> adviceConstructorArgumentValues
        }
    }



    package "aop:aspect=>advisor" {
        'advisor
        map "advisorDefinition.PropertyValues" as advisorPropertyValues {
            aspectName => aspectName(ref)
            order => order(order)
        }
        map "advisorDefinition.ConstructorArgumentValues" as advisorConstructorArgumentValues {
            List<ValueHolder> genericArgumentValues => 下面是list的内容
            0 =>
        }
        advisorConstructorArgumentValues::0 --> adviceDefinition

        map advisorDefinition {
            class => RootBeanDefinition
            beanClass => AspectJPointcutAdvisor.class
            getConstructorArgumentValues *--> advisorConstructorArgumentValues
            getPropertyValues *--> advisorPropertyValues
        }
        note top of advisorDefinition
        解析 aop:aspect 及其子元素,转成bd并注册
        aspect元素下,一个advice注册一个advisor BeanDefinition
        #aop:before
        #aop:after
        #aop:after-returning
        #aop:around
        #aop:after-throwing
        BeanDefinition注册时的名字都是自动生成的
        ===
        在aop:config下的直接advisor beanClass不同
        end note
    }

'aop:config=>advisor
    package aop:config=>advisor {
        map "advisorDefinition2.PropertyValues" as advisor2PropertyValues {
            adviceBeanName => new RuntimeBeanNameReference(advice-ref)
            order => order(order)
        }
        map advisorDefinition2 {
            class => RootBeanDefinition
            beanClass => DefaultBeanFactoryPointcutAdvisor.class
            getPropertyValues *--> advisor2PropertyValues
        }
    }

'aop:declare-parents
    package aop:declare-parents {
        map "declareDefinition.ConstructorArgumentValues" as declareConstructorArgumentValues {
            Map<Integer, ValueHolder> indexedArgumentValues => 下面是map内容
            0 => new ValueHolder(implement-interface)
            1 => new ValueHolder(types-matching)
            2_default => new ValueHolder(default-impl)
            2_ref => new RuntimeBeanReference(delegate-ref)
        }
        map declareDefinition {
            class => RootBeanDefinition
            beanClass => DeclareParentsAdvisor.class
            getConstructorArgumentValues *--> declareConstructorArgumentValues
        }
    }

}





@enduml