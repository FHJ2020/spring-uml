@startuml
'https://plantuml.com/activity-diagram-beta

floating note
<color:Purple> 紫色 BeanFactoryPostProcessor 子类
<color:red> 红色 BeanPostProcessor 子类
====

end note
start
card "Parse BeanDefinition" #tan{
    note
    **beanDefinition第一次处理**
    ----
    AbstractRefreshableApplicationContext
    在refreshBeanFactory()方法中解析并注册beanDefinition
    xml完全解析
    注解半解析
    ----
    GenericApplicationContext
    不主动解析和注册beanDefinition
    annotation子类
    通常解析、注册beanDefinition
    都是只处理@component注解
    其他注解需要在以下回调方法中处理
    #BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry
    #BeanFactoryPostProcessor.postProcessBeanFactory
    #MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition

    end note

    :resolve NamespaceHandler;
    note left
    NamespaceHandlerResolver.resolve
    handler默认定义位置 META-INF/spring.handlers
    NamespaceHandler
    NamespaceHandlerSupport
    #ContextNamespaceHandler
    #AopNamespaceHandler
    end note
    :handler.init
    #registerBeanDefinitionParser
        parser会注册postProcessors
    #registerBeanDefinitionDecorator
    ;
    :handler.parse
    #get BeanDefinitionParser
    #BeanDefinitionParser.parse
    #generate BeanDefinition;
    note
    **xml方式**
    bean中的所有属性被解析成PropertyValue,被添加到propertyValues字段中
    end note

    :register PostProcessors BeanDefinition;
    note
    **default NamespaceHandler register PostProcessors**

    **aop NamespaceHandler register PostProcessors**
    AspectJAwareAdvisorAutoProxyCreator

    end note

    :register BeanDefinition;
}


card "Parse BeanDefinition After" #tan{
    note
    **beanDefinition第二次解析**
    **特点**
    回调接口对bean进行额外处理
    #BeanFactoryPostProcessor
    #BeanDefinitionRegistryPostProcessor

    end note

    :getBean BeanDefinitionRegistryPostProcessor;
    :<color:red> BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry;
    note
    **annotation callback**
    ConfigurationClassPostProcessor
    end note
    :getBean BeanFactoryPostProcessor;
    :<color:red> BeanFactoryPostProcessor.postProcessBeanFactory;
    note
    **annotation callback**
    EventListenerMethodProcessor
    end note

    :SmartInitializingSingleton.afterSingletonsInstantiated;
    note
    **annotation callback**
    EventListenerMethodProcessor
    end note
}


card "getSingleton" {
    :通过 ObjectFactory 返回不完整对象
    SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference
    ;
}

card "Instantiation Before" #skyblue    {
    :<color:Purple> InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation;
    note
    **annotation callback**
    end note

}

card "Instantiation"{
split
    :SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors
    对构造函数进行拦截
    ;
    note
    **annotation callback**
    AutowiredAnnotationBeanPostProcessor
    end note
split again
    :instanceSupplier;
split again
    :FactoryMethod;

endsplit
    :实例已经构造,还未调用lifecycle相关方法、未依赖注入;
    :<color:Purple> MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition;
    note
    **beanDefinition第三次解析**
    **default**
    ApplicationListenerDetector
    **annotation callback**
    AutowiredAnnotationBeanPostProcessor
    CommonAnnotationBeanPostProcessor
    解析注解并放入rbd.externallyManagedXXX字段中

    end note
    :添加一个 ObjectFactory 使用回调处理循环引用,无回调默认返回当前对象,不完整的bean对象
    被依赖对象通过 getSingleton方法调用 ObjectFactory 获得不完整bean对象
    <color:Purple> SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference对早期引用进行拦截
    ;
    note
    if (!this.singletonObjects.containsKey(beanName)) {
        this.singletonFactories.put(beanName, singletonFactory);
        this.earlySingletonObjects.remove(beanName);
        this.registeredSingletons.add(beanName);
    }
    end note
}

card "Instantiation After" #skyblue {
    :<color:Purple> InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation;
    :<color:Purple> InstantiationAwareBeanPostProcessor.postProcessProperties;
    note
    **annotation callback**
    AutowiredAnnotationBeanPostProcessor
    CommonAnnotationBeanPostProcessor
    将injectionMetadataCache中的依赖,注入到bean实例中,这一步会调用getBean去获取属性中的bean
    end note
    :<color:Purple> InstantiationAwareBeanPostProcessor.postProcessPropertyValues;
    note
    **annotation callback**
    AutowiredAnnotationBeanPostProcessor
    CommonAnnotationBeanPostProcessor
    end note
    :applyPropertyValues
    解析propertyValues中的依赖并注入到bean实例中;
}


card "Initialization Before" #tan {
    :invokeAwareMethods
    #BeanNameAware
    #BeanClassLoaderAware
    #BeanFactoryAware;
    :<color:Purple> BeanPostProcessor.postProcessBeforeInitialization;
    note
        SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference 功能相似
        **default**
        ApplicationContextAwareProcessor
        BeanPostProcessorChecker
        **annotation callback**
        ConfigurationClassPostProcessor
        CommonAnnotationBeanPostProcessor

    end note
    :applyPropertyValues;
    note
    xml方式：解析 beanDefinition时 全部处理完毕
    annotation方式：在Instantiation After阶段解析类内部的注解，并添加到tPropertyValues中
    beanDefinition.getPropertyValues()进行依赖注入
    end note

}

card "Initialization" {
    :InitializingBean.afterPropertiesSet;
    :invokeCustomInitMethod(beanName, bean, mbd);

}

card "Initialization After" #tan {
    :<color:Purple> BeanPostProcessor.postProcessAfterInitialization;
    note
        SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference 功能相似
        **default**
        ApplicationListenerDetector
    end note
}
card "Use Before"{
split
    :registerDisposableBean;
split again
    :scope.registerDestructionCallback;
endsplit

}
:use;

card "destroy Before" #skyblue {
    :DestructionAwareBeanPostProcessor.postProcessBeforeDestruction;
    note
    **default**
    ApplicationListenerDetector
    **annotation callback**
    CommonAnnotationBeanPostProcessor
    end note
}
:"destroy";
stop

@enduml
